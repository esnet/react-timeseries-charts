import { scaleTime, scaleUtc } from "d3-scale";
import _ from "lodash";
import { TimeRange } from "pondjs";
import React, { ReactElement, useRef } from "react";
import { TimeAxisStyle } from "../style";
import { LabelValueList, ShowGridPosition } from "../types";
import ChartRow, { ChartRowProps } from "./ChartRow";
import { Charts } from "./charts/Charts";
import { TimeAxis } from "./Axis/TimeAxis";

// TODO: import from './styles'?
const defaultChartAxisStyle = {};
const defaultStyle = {};

export type TimeFormat = "second" | "hour" | "day" | "month" | "year";

export interface ChartContainerProps {
    /**
     * Children of the ChartContainer should be ChartRows.
     */
    children: any;

    /**
     * A Pond TimeRange representing the begin and end time of the chart.
     */
    timeRange: TimeRange;

    /**
     * The timezone the time axis should be in
     */
    timezone?: string;

    /**
     * The width of the chart. This library also includes a <Resizable> component
     * that can be wrapped around a \<ChartContainer\>. The purpose of this is to
     * inject a width prop into the `ChartContainer` so that it will fit the
     * surrounding element. This is very handy when you need the chart to resize
     * based on a responsive layout.
     */
    width?: number;

    /**
     * Constrain the TimeRange to not move back in time further than this Date.
     */
    minTime?: Date;

    /**
     * Constrain the TimeRange to not move forward in time than this Date. A
     * common example is setting this to the current time or the end time
     * of a fixed set of data.
     */
    maxTime?: Date;

    /**
     * The format for the tick labels.
     *
     * The default it to compute this automatically. You can also specify this
     * as a string or function.
     *
     * Six special options exist, specified as a string: setting format to:
     *  * "second",
     *  * "hour"
     *  * "day"
     *  * "month"
     *  * "year"
     *
     * will show only ticks on those, and every one of those intervals.
     *
     * For example maybe you are showing a bar chart for October 2014 then setting
     * the format to "day" will insure that a label is placed for each and every day,
     * all 31 of them. Be careful though, it's easy to add too many labels this way.
     *
     * The last string option is:
     *  * "duration".
     *
     * This interprets the time as a duration. This is good for data that is
     * specified relative to its start time, rather than as an actual date/time.
     *
     * Finally, format can also be a function. The function will be passed the date
     * it is rendering. It expects the return result to be a an object describing
     * the resulting tick. For example:
     *
     * ```js
     *     format = (d) => ({
     *         label: moment(d).format(h:mm a),
     *         size: 15,
     *         labelAlign: "adjacent"
     *     });
     * ```
     */
    timeFormat?: TimeFormat | ((d: Date) => TimeFormat);

    /**
     * Object specifying the CSS by which the `TimeAxis` can be styled. The object can contain:
     * "values" (the time labels), "axis" (the main horizontal line) and "ticks" (which may
     * optionally extend the height of all chart rows using the `showGrid` prop. Each of these
     * is an inline CSS style applied to the axis label, axis values, axis line and ticks
     * respectively.
     *
     * Note that "ticks" and "values" are passed into d3's styles, so they are regular CSS property names
     * and not React's camel case names (e.g. "stroke-dasharray" not "strokeDasharray"). "axis" is a
     * regular React rendered SVG line, so it uses camel case.
     */
    timeAxisStyle?: TimeAxisStyle;

    /**
     * Angle the time axis labels
     */
    timeAxisAngledLabels?: boolean;

    /**
     * Refers to the styling of the axis generated by the Chart Container
     */
    chartAxisStyle?: any;

    /**
     * Boolean to turn on interactive pan and zoom behavior for the chart.
     */
    enablePanZoom?: boolean;

    /**
     * Boolean to turn on interactive drag to zoom behavior for the chart.
     */
    enableDragZoom?: boolean;

    /**
     * If this is set the timerange of the chart cannot be zoomed in further
     * than this duration, in milliseconds. This might be determined by the
     * resolution of your data.
     */
    minDuration?: number;

    /**
     * Time in milliseconds to transition from one Y-scale to the next
     */
    transition?: number;

    /**
     * Padding to add
     */
    padding?: number;
    paddingLeft?: number;
    paddingRight?: number;
    paddingTop?: number;
    paddingBottom?: number;
    timeAxisHeight?: number;
    leftWidth?: number;
    rightWidth?: number;

    /**
     * Show grid lines for each time marker
     */
    showGrid?: boolean;

    /**
     * Defines whether grid is overlayed ("ShowGridPosition.Over") or underlayed ("ShowGridPosition.Under")
     * with respect to the charts
     */
    showGridPosition?: ShowGridPosition;

    /**
     * A Date specifying the position of the tracker line on the chart. It is
     * common to take this from the onTrackerChanged callback so that the tracker
     * followers the user's cursor, but it could be modified to snap to a point or
     * to the nearest minute, for example.
     */
    trackerTime?: Date;

    /**
     * Info box value or values to place next to the tracker line.
     * This is either an array of objects, with each object
     * specifying the label and value to be shown in the info box,
     * or a simple string label.
     */
    trackerInfo?: LabelValueList | string;

    /**
     * The width of the tracker info box
     */
    trackerInfoWidth?: number;

    /**
     * The height of the tracker info box
     */
    trackerInfoHeight?: number;

    /**
     * Will be called when the user hovers over a chart. The callback will
     * be called with the timestamp (a Date object) of the position hovered
     * over as well as the current time axis' time scale. The timestamp may
     * be used as the trackerPosition (see above), or to provide information
     * about the time hovered over within the greater page. The time scale
     * may be used to translate the timestamp into an x coordinate, which
     * can then be used to position arbitrary components in sync with the
     * current tracker position.
     * Commonly we might do something like this:
     * ```
     *   <ChartContainer
     *     onTrackerChanged={(tracker) => this.setState({tracker})}
     *     trackerPosition={this.state.tracker}
     *     ... />
     * ```
     */
    onTrackerChanged?: (time: Date, number: (t: any) => number) => any;

    /**
     * This will be called if the user pans and/or zooms the chart. The callback
     * will be called with the new TimeRange. This can be fed into the timeRange
     * prop as well as used elsewhere on the greater page. Typical use might look
     * like this:
     * ```
     *   <ChartContainer
     *     onTimeRangeChanged={(timerange) => this.setState({timerange})}
     *     timeRange={this.state.timerange}
     *     ... />
     * ```
     */
    onTimeRangeChanged?: (timerange: TimeRange) => any;

    /**
     * Called when the user clicks the background plane of the chart. This is
     * useful when deselecting elements.
     */
    onBackgroundClick?: () => any;

    onMouseMove?: (x: number, y: number) => any;

    /**
     * Specify the title of the chart
     */
    title?: string;

    /**
     * Define the height of the title label
     */
    titleHeight?: number;

    /**
     * Define the styling of the chart's title
     */
    titleStyle?: React.CSSProperties;

    /**
     * Style the chart container
     */
    style?: React.CSSProperties;
}

const ChartContainer: React.FunctionComponent<ChartContainerProps> = (
    props: ChartContainerProps
) => {
    // Default values
    const {
        timezone = "local",
        timeRange,
        width = 800,
        padding = 0,
        minTime,
        maxTime,
        enablePanZoom = false,
        // enableDragZoom = false,
        minDuration,
        showGrid = false,
        timeFormat,
        timeAxisHeight = 35,
        showGridPosition = ShowGridPosition.Over,
        title,
        titleHeight = 28
    } = props;

    // Default dimensional padding values to the padding prop
    const {
        paddingLeft = padding,
        paddingRight = padding,
        paddingTop = padding,
        paddingBottom = padding
    } = props;

    console.log("Rendering ChartContainer");

    // Reference to our main SVG container
    const svg = useRef(null);

    let leftWidth: number;
    let rightWidth: number;

    // Arrays to keep track of the widths on right and left of the charts
    const chartRows: JSX.Element[] = [];
    const leftAxisWidths: number[] = [];
    const rightAxisWidths: number[] = [];

    //
    // Main loop over the children ChartRows to determine layout
    //
    // How much room does the axes of all the charts take up on the right
    // and left? The result is an array for left and right axis which
    // contain the min column width needed to hold the axes widths at the
    // pos for all rows.
    //
    // pos   1      0        <charts>     0        1        2
    //     | Axis | Axis |   CHARTS    |  Axis  |                      Row 1
    //            | Axis |   CHARTS    |  Axis  |  Axis  |  Axis |     Row 2
    //     ...............              ..........................
    //          left cols              right cols
    //
    React.Children.forEach(props.children, (childRow: ReactElement<ChartRowProps>) => {
        if ((childRow.type as React.ComponentType<any>) === ChartRow) {
            console.log("   - Found ChartRow");
            //
            // Within this row, count the number of columns that will be left and right of the Charts tag,
            // as well as the total number of Charts tags for error handling
            //

            let countLeft: number = 0;
            let countCharts: number = 0;
            let align: string = "left";

            React.Children.forEach(childRow.props.children, (child: ReactElement<any>) => {
                if (child === null) return;
                if ((child.type as React.ComponentType<any>) === Charts) {
                    countCharts += 1;
                    align = "right";
                } else {
                    // } else if (
                    //     !child.type as React.ComponentType<any> === Brush) &&
                    //     !child.type as React.ComponentType<any> === MultiBrush)
                    // ) {
                    if (align === "left") {
                        countLeft += 1;
                    }
                }
            });

            if (countCharts !== 1) {
                const msg = "ChartRow should have one and only one <Charts> tag within it";
                console.error(msg);
            }

            align = "left";
            let pos = countLeft - 1;

            React.Children.forEach(childRow.props.children, (child: ReactElement<any>) => {
                if (child === null) return;
                if (
                    (child.type as React.ComponentType<any>) === Charts // ||
                    // child.type as React.ComponentType<any> === Brush  ||
                    // child.type as React.ComponentType<any> === MultiBrush
                ) {
                    if ((child.type as React.ComponentType<any>, Charts)) {
                        align = "right";
                        pos = 0;
                    }
                } else {
                    let width = Number(child.props.width) || 40;
                    const visible = !_.has(child.props, "visible") || child.props.visible;
                    if (!visible) width = 0;

                    if (align === "left") {
                        leftAxisWidths[pos] = leftAxisWidths[pos]
                            ? Math.max(width, leftAxisWidths[pos])
                            : width;
                        pos -= 1;
                    } else if (align === "right") {
                        rightAxisWidths[pos] = rightAxisWidths[pos]
                            ? Math.max(width, rightAxisWidths[pos])
                            : width;
                        pos += 1;
                    }
                }
            });
        }
    });

    console.log("AxisWidth arrays:", leftAxisWidths, rightAxisWidths);

    // Space used by columns on left and right of charts
    leftWidth = _.reduce(leftAxisWidths, (a, b) => a + b, 0);
    rightWidth = _.reduce(rightAxisWidths, (a, b) => a + b, 0);

    console.log("Axis used space:", leftWidth, rightWidth);

    // Horizontal space used by the charts and the time axis
    let chartsHeight = 0;
    const chartsWidth = width - leftWidth - rightWidth - paddingLeft - paddingRight;

    // Based on the horizontal space available for the charts and the time axis, we can
    // construct a d3 scale that will be used for the time axis scaling for all charts
    // and the x axis itself
    const timeScale =
        timezone === "Etc/UTC"
            ? scaleUtc()
                  .domain([timeRange.begin(), timeRange.end()])
                  .range([0, chartsWidth])
            : scaleTime()
                  .domain([timeRange.begin(), timeRange.end()])
                  .range([0, chartsWidth]);

    console.log("Time domain:", timeScale.domain());

    let i = 0;
    let yPosition = 0;

    // Chart title
    const titleRenderedHeight = _.isUndefined(title) ? titleHeight : 0;
    // XXX TODO

    // Charts
    console.log("Adding charts");
    React.Children.forEach(props.children, (child: ReactElement<any>) => {
        if ((child.type as React.ComponentType<any>) === ChartRow) {
            const chartRow = child;
            const rowKey = `chart-row-row-${i}`;
            const firstRow = i === 0;
            const isVisible = child.props.visible ? child.props.visible : true;
            console.log(" - ChartRow", rowKey, firstRow, isVisible);
            if (isVisible) {
                const height = parseInt(child.props.height, 10);
                const chartRowProps: ChartRowProps = {
                    timeScale,
                    paddingLeft,
                    paddingRight,
                    leftAxisWidths,
                    rightAxisWidths,
                    width,
                    height,
                    minTime,
                    maxTime,
                    enablePanZoom,
                    minDuration,
                    showGrid,
                    timeFormat,
                    axisMargin: 0,
                    trackerShowTime: firstRow,
                    trackerTime: props.trackerTime,
                    trackerTimeFormat: props.timeFormat,
                    onTimeRangeChanged: () => {}, // XXX onTimeRangeChanged: tr => handleTimeRangeChanged(tr),
                    onTrackerChanged: () => {} // XXX onTrackerChanged: t =>handleTrackerChanged(t)
                };

                const transform = `translate(${-leftWidth - paddingLeft},${yPosition})`;

                chartRows.push(
                    <g transform={transform} key={rowKey}>
                        {React.cloneElement(chartRow, chartRowProps)}
                    </g>
                );

                yPosition += height;
                chartsHeight += height;
            }
        }
        i += 1;
    });

    console.log("chartRows", chartRows);

    //
    // Final render of the ChartContainer is composed of a number of
    // chartRows, a timeAxis and the tracker indicator
    //

    const svgWidth = width;
    const svgHeight = yPosition + timeAxisHeight + paddingTop + paddingBottom + titleRenderedHeight;

    console.log("svg size", svgWidth, svgHeight);

    //
    // TimeAxis
    //
    const timeAxisStyle = _.merge({}, defaultStyle, props.timeAxisStyle || {});

    const chartAxisStyle = _.merge({}, defaultChartAxisStyle, props.chartAxisStyle || {});
    const tickSize = showGrid ? chartsHeight : 0;
    const timeAxis = (
        <g
            transform={`translate(${leftWidth + paddingLeft},${paddingTop +
                titleHeight +
                chartsHeight})`}
        >
            <line
                x1={-leftWidth}
                y1={0.5}
                x2={chartsWidth + rightWidth}
                y2={0.5}
                style={chartAxisStyle}
            />
            <TimeAxis
                timezone={timezone}
                position="bottom"
                beginTime={new Date(timeRange.begin().getTime())}
                endTime={new Date(timeRange.end().getTime())}
                width={chartsWidth}
                margin={0}
                height={50}
                tickExtend={tickSize}
                style={timeAxisStyle}
                format={props.timeFormat}
                angled={props.timeAxisAngledLabels}
            />
        </g>
    );

    //
    // Event handler XXX Wrap in EventHandler
    //

    const rows = (
        <g transform={`translate(${leftWidth + paddingLeft},${paddingTop + titleRenderedHeight})`}>
            <g>{chartRows}</g>
        </g>
    );

    return showGridPosition.toUpperCase() === ShowGridPosition.Over ? (
        <svg
            width={svgWidth}
            height={svgHeight}
            // style={svgStyle}
            ref={svg}
        >
            {/* {title} */}
            {rows}

            {/*
            {tracker}
            */}
            {timeAxis}
        </svg>
    ) : (
        <svg
            width={svgWidth}
            height={svgHeight}
            // style={svgStyle}
            ref={svg}
        >
            {rows}

            {/*
            {title}
            {rows}
            {tracker} */}
            {timeAxis}
        </svg>
    );
};

export default ChartContainer;
