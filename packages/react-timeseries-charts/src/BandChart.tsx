/**
 *  Copyright (c) 2015-present, The Regents of the University of California,
 *  through Lawrence Berkeley National Laboratory (subject to receipt
 *  of any required approvals from the U.S. Dept. of Energy).
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree.
 */

import * as _ from "lodash";
import * as Immutable from "immutable";
import * as React from "react";

import { area } from "d3-shape";
import { 
    Event,
    Key,
    index,
    Index,
    max,
    median,
    min,
    percentile,
    Time,
    TimeSeries,
    duration,
    window
} from "pondjs";
import { ReducerFunction } from "pondjs/lib/types";

import { AreaData } from './AreaChart';
import { AggregationSpec } from './BoxChart';
import { ChartProps } from "./Charts";
import curves from "./curve";
import { CurveInterpolation, LabelValueList } from "./types";
import { Styler } from "./styler";
import { scaleAsString } from "./util";

import {
    BandChartStyle,
    BandChartChannelStyle as ChannelStyle,
    LevelStyle,
    defaultBandChartStyle as defaultStyle,
    EventMarkerStyle
} from "./style";

/**
 * The default version of the AggregationSpec, which will result in a classic
 * BandPlot with outer band being min to max, inner band being the 25th and 75th
 * percentiles, and a marker at the center for the medium.
 */
const defaultAggregation: AggregationSpec = {
    size: window(duration("5m")),
    reducers: {
        outer: [min(), max()],
        inner: [percentile(25), percentile(75)],
        center: median()
    }
};

/**
 * Defines a structure that will hold the actual ranges to be plotted, whether they
 * come from the chart itself doing the aggregation or are supplied pre-baked from
 * the user.
 */
export type BandChartRanges = {
    center: number;
    innerMin: number;
    innerMax: number;
    outerMin: number;
    outerMax: number;
};

/**
 * Remaps a `TimeSeries<Index>` which is assumed to have an array of between 1 and 5 values
 * at the `column` specified to a a new TimeSeries<Index>, where each Index is associated with
 * a structure containing outer and inner ranges along with center.
 *
 * The input `TimeSeries` is the format the user should supply to the series if they want
 * to pre-bake the ranges. The output `TimeSeries` is the format actually plotted. If the
 * chart itself does the aggregation then this same output format will be generated by the
 * function `getAggregatedSeries()` below.
 */
function getSeries(series: TimeSeries<Index>, column: string): TimeSeries<Index> {
    return series.map(e => {
        const v = e.get(column);
        const d: BandChartRanges = {
            center: null,
            innerMin: null,
            innerMax: null,
            outerMin: null,
            outerMax: null
        };
        switch (v.size) {
            case 1:
                d.center = v.get(0);
                break;
            case 2:
                d.innerMin = v.get(0);
                d.innerMax = v.get(1);
                break;
            case 3:
                d.innerMin = v.get(0);
                d.center = v.get(1);
                d.innerMax = v.get(2);
                break;
            case 4:
                d.outerMin = v.get(0);
                d.innerMin = v.get(1);
                d.innerMax = v.get(2);
                d.outerMax = v.get(3);
                break;
            case 5:
                d.outerMin = v.get(0);
                d.innerMin = v.get(1);
                d.center = v.get(2);
                d.innerMax = v.get(3);
                d.outerMax = v.get(4);
                break;
            default:
                console.error("Tried to make bandchart from invalid array");
        }
        const ee = new Event(index(e.indexAsString()), Immutable.Map(d));
        return ee;
    });
}

/**
 * Takes in a TimeSeries and an AggregationSpec and builds a new TimeSeries<Index>
 * which will be rendered by the chart. The `AggregationSpec` is a combination of
 * the windowing size to use (e.g. 5 minutes) and the reducer functions used to
 * build the inner and outer ranges, along with the center. For example:
 * ```
 * {
 *    size: window(duration("5m")),
 *    reducers: {
 *        outer: [min(), max()],
 *        inner: [percentile(25), percentile(75)],
 *        center: median()
 *    }
 * }
 * ```
 */
function getAggregatedSeries(
    series: TimeSeries<Key>, 
    column: string, 
    aggregation: AggregationSpec = defaultAggregation
): TimeSeries<Index> {
    const { size, reducers } = aggregation;
    const { inner, outer, center } = reducers;

    type FixedWindowAggregation = {
        center: [string, ReducerFunction];
        innerMin: [string, ReducerFunction];
        innerMax: [string, ReducerFunction];
        outerMin: [string, ReducerFunction];
        outerMax: [string, ReducerFunction];
    };

    const d: Partial<FixedWindowAggregation> = {};

    if (inner) {
        d.innerMin = [column, inner[0]];
        d.innerMax = [column, inner[1]];
    }

    if (outer) {
        d.outerMin = [column, outer[0]];
        d.outerMax = [column, outer[1]];
    }

    if (center) {
        d.center = [column, center];
    }

    return series.fixedWindowRollup({
        window: size,
        aggregation: d
    });
}

export type BandChartProps = ChartProps & {
    /**
     * What [Pond TimeSeries](http://software.es.net/pond/#/class/timeseries)
     * data to visualize. See general notes on the BandChart.
     */
    series: TimeSeries<Index> | TimeSeries<Time>,

    /**
     * The column within the TimeSeries to plot. Unlike other charts, the BandChart
     * works on just a single column.
     */
    column?: string,

    /**
     * The aggregation specification. This object should contain:
     *   - innerMax
     *   - innerMin
     *   - outerMax
     *   - outerMin
     *   - center
     * Though each of the pairs, and center, is optional.
     * For each of these keys you should supply the function you
     * want to use to calculate these. You can import common functions
     * from Pond, e.g. min(), avg(), percentile(95), etc.
     *
     * For example:
     * ```
     *     {
     *       size: this.state.rollup,
     *       reducers: {
     *         outer: [min(), max()],
     *         inner: [percentile(25), percentile(75)],
     *         center: median(),
     *       },
     *     }
     * ```
     */
    aggregation?: AggregationSpec;

    /**
     * The style of the box chart drawing (using SVG CSS properties) or
     * a styler object. It is recommended to user the styler unless you need
     * detailed customization.
     */
    style?: BandChartStyle | ((channel: string) => ChannelStyle) | Styler;
    
    /**
     * The values to show in the info box. This is either an array of
     * objects, with each object specifying the label and value
     * to be shown in the info box, or it can also be a string.
     * 
     * For example:
     * ```
     * infoValues = [{ 
     *      label: "Traffic", 
     *      value: trafficText 
     * }];
     * ```
     */
    info?: LabelValueList | string;

    /**
     * The style of the info box itself and the connecting lines. 
     * Typically, this is an object where the key can describe 
     * the stying of the stem, marker, box  and the text of the infoBox. 
     * The style for each of them is in the form of CSS properties
     * 
     * For example:
     * ```
     * infoStyle = {
     *      box: {
     *          fill: "black",
     *          color: "#DDD"
     *      }
     * }
     * ```
     */
    infoStyle?: EventMarkerStyle;
    
    /**
     * Alter the format of the timestamp shown on the info box.
     * This may be either a function or a string. If you provide a function
     * that will be passed an Index and should return a string. For example:
     * ```
     * index => moment(index.begin()).format("Do MMM 'YY")
     * ```
     * Alternatively you can pass in a d3 format string. That will be applied
     * to the begin time of the Index range.
     */
    infoTimeFormat?: ((date: Date) => string) | string;

    /**
     * The width of the hover info box
     */
    infoWidth?: number;

    /**
     * The height of the hover info box
     */
    infoHeight?: number;

    /**
     * The radius of the dot at the end of the marker
     */
    infoMarkerRadius?: number;

    /**
     * Any of D3's interpolation modes.
     * For reference - [d3-curves](https://github.com/d3/d3-shape#curves)
     */
    interpolation: CurveInterpolation;

    /**
     * If spacing is specified, then the boxes will be separated from the
     * timerange boundary by this number of pixels. Use this to space out
     * the boxes from each other. Inner and outer boxes are controlled
     * separately.
     */ 
    innerSpacing?: number;

    /**
     * If spacing is specified, then the boxes will be separated from the
     * timerange boundary by this number of pixels. Use this to space out
     * the boxes from each other. Inner and outer boxes are controlled
     * separately.
     */
    outerSpacing?: number;

    /**
     * If size is specified, then the innerBox will be this number of pixels wide. This
     * prop takes priority over `spacing`.
     */
    innerSize?: number;

    /**
     * If size is specified, then the outer box will be this number of pixels wide. This
     * prop takes priority over "spacing".
     */
    outerSize?: number;

    /**
     * The selected item, which will be rendered in the `selected` style.
     * If a bar is selected, all other bars will be rendered in the "muted" style.
     *
     * See also `onSelectionChange`
     */
    selected?: Event<Index>;

    /**
     * The highlighted item, which will be rendered in the `highlighted` style.
     *
     * See also `onHighlightChange`
     */
    highlighted?: Event<Index>;

    /**
     * Show or hide this chart
     */
    visible: boolean;

    /**
     * A callback that will be called when the selection changes. It will be called
     * with the event corresponding to the box clicked as its only arg.
     */
    onSelectionChange?: (column: string) => any;

    /**
     * A callback that will be called when the hovered over box changes.
     * It will be called with the event corresponding to the box hovered over.
     */
    onHighlightChange?: (column: string) => any;
};

/**
 * Renders a band chart.
 *
 * The TimeSeries supplied to the band chart, as the `series` prop can be one of two types:
 *
 *  1) It can be a TimeSeries containing IndexedEvents or TimeRangeEvents.
 *     In this case a `column` prop should be supplied to specify the
 *     data column containing the dimensions of the bands. This props
 *     should be an array of size 1 to 5 elements. e.g. [12, 18, 22, 28]. The
 *     numbers should be ordered, lowest to greatest.
 *
 *  2) A TimeSeries containing timestamp based Events. In this case the
 *     band chart will be aggregated for you. To control the aggregation you can supply
 *     an `aggregation` prop: a structure to specify the window size and
 *     reducers used to determine the bands.
 *
 * In both cases you are generating up to two ranges and a center marker. In the
 * first case you are defining this based on the array of numbers. The outer numbers
 * specify the outerRange, the inner numbers specify the innerRange and the middle
 * number specifies the center marker. In the second case you are building those ranges
 * from denser data, specifying a window and aggregation functions to build each
 * of the ranges and center maker.
 *
 * In both cases you do not need to supply all the values. For example if you
 * provide an array of 2 elements, that would define a single range, with no outer range
 * and no center marker. The Band Chart is pretty flexible in that way, so you
 * can use it in many situations.
 *
 * Here is an example of using it to display temperature ranges. The series
 * passed to this code would be a TimeSeries containing IndexedEvents. For
 * each event, the column `temp` contains an array of values used for the
 * band plot ranges:
 *
 * ```
 * <BandChart
 *     axis="temperatureAxis"
 *     style={style}
 *     column="temp"
 *     series={series} />
 * ```
 *
 * While here is an example with a dense TimeSeries of Events supplied,
 * along with an aggregation specification. This code would produce an
 * outer range from the 5th percentile to the 95th, along with an inner
 * range for the interquantile, and a center marker at the median:
 *
 * ```
 * <BandChart
 *     axis="speedaxis"
 *     series={speed}
 *     column="speed"
 *     style={style}
 *     aggregation={{
 *         size: this.state.rollup,
 *         reducers: {
 *             outer: [percentile(5), percentile(95)],
 *             inner: [percentile(25), percentile(75)],
 *             center: median(),
 *         },
 *     }}
 * />
 * ```
 */
export class BandChart extends React.Component<BandChartProps> {
    static defaultProps = {
        column: "value",
        innerSpacing: 1.0,
        outerSpacing: 2.0,
        infoMarkerRadius: 2,
        infoWidth: 90,
        infoHeight: 30
    };

    // Cached series
    series: TimeSeries<Index>;

    // Cached styles
    providedStyle: LevelStyle[];

    selectedStyle: any;
    highlightedStyle: any;
    mutedStyle: any;
    normalStyle: any;

    constructor(props: BandChartProps) {
        super(props);
        this.series = null;
        if (props.series.size() > 0) {
            if (props.series.atFirst().keyType() === "time") {
                const input = props.series as TimeSeries<Time>;
                this.series = getAggregatedSeries(input, props.column, props.aggregation);
            } else {
                const input = props.series as TimeSeries<Index>;
                this.series = getSeries(input, props.column);
            }
        }
    }

    componentWillReceiveProps(nextProps: BandChartProps) {
        const aggregation = nextProps.aggregation;

        let aggregationChanged = false;
        if (_.isUndefined(aggregation) !== _.isUndefined(this.props.aggregation)) {
            aggregationChanged = true;
        }

        if (aggregation && this.props.aggregation) {
            if (aggregation.size !== this.props.aggregation.size) {
                aggregationChanged = true;
            }
        }

        if (aggregationChanged) {
            this.series = getAggregatedSeries(
                nextProps.series,
                nextProps.column,
                nextProps.aggregation
            );
        }
    }

    shouldComponentUpdate(nextProps: BandChartProps): boolean {
        const newSeries = nextProps.series;
        const width = nextProps.width;
        const timeScale = nextProps.timeScale;
        const yScale = nextProps.yScale;
        const column = nextProps.column;
        const style = nextProps.style;
        const aggregation = nextProps.aggregation;
        const highlighted = nextProps.highlighted;
        const selected = nextProps.selected;

        const oldSeries = this.props.series;
        const widthChanged = this.props.width !== width;
        const timeScaleChanged = scaleAsString(this.props.timeScale) !== scaleAsString(timeScale);
        const yAxisScaleChanged = this.props.yScale !== yScale;
        const columnChanged = this.props.column !== column;
        const styleChanged = JSON.stringify(this.props.style) !== JSON.stringify(style);
        const highlightedChanged = this.props.highlighted !== highlighted;
        const selectedChanged = this.props.selected !== selected;

        let aggregationChanged = false;
        if (_.isUndefined(aggregation) !== _.isUndefined(this.props.aggregation)) {
            aggregationChanged = true;
        }

        if (aggregation && this.props.aggregation) {
            if (aggregation.size !== this.props.aggregation.size) {
                aggregationChanged = true;
            }
        }

        let seriesChanged = false;
        if (oldSeries.size() !== newSeries.size()) {
            seriesChanged = true;
        } else {
            seriesChanged = !TimeSeries.is(oldSeries, newSeries);
        }

        // If the series changes we need to rebuild this.series with
        // the incoming props
        if (seriesChanged) {
            if (nextProps.series.size() > 0) {
                if (nextProps.series.atFirst().keyType() === "time") {
                    const input = nextProps.series as TimeSeries<Time>;
                    this.series = getAggregatedSeries(
                        input,
                        nextProps.column,
                        nextProps.aggregation
                    );
                } else {
                    const input = nextProps.series as TimeSeries<Index>;
                    this.series = getSeries(
                        nextProps.series as TimeSeries<Index>,
                        nextProps.column
                    );
                }
            }
        }

        return (
            seriesChanged ||
            timeScaleChanged ||
            widthChanged ||
            columnChanged ||
            styleChanged ||
            yAxisScaleChanged ||
            aggregationChanged ||
            highlightedChanged ||
            selectedChanged
        );
    }

    handleHover(e: React.MouseEvent<SVGElement>, column: string) {
        if (this.props.onHighlightChange) {
            this.props.onHighlightChange(column);
        }
    }

    handleHoverLeave() {
        if (this.props.onHighlightChange) {
            this.props.onHighlightChange(null);
        }
    }

    handleClick(e: React.MouseEvent<SVGElement>, column: string) {
        if (this.props.onSelectionChange) {
            this.props.onSelectionChange(column);
        }
        e.stopPropagation();
    }

    /**
     * Given a `column`, look up the ChannelStyle.
     */
    providedStyleArray(column: string): LevelStyle[] {
        let style: LevelStyle[] = defaultStyle;
        if (this.props.style) {
            if (this.props.style instanceof Styler) {
                style = this.props.style.bandChartStyle()[column];
            } else if (_.isFunction(this.props.style)) {
                style = this.props.style(column);
            } else if (_.isObject(this.props.style)) {
                style = this.props.style[column];
            }
        }
        return style;
    }

    /**
     * Returns the style of a specific column, at a specific level taking into
     * account the mode of the Event (selected, highlighted etc). This is the
     * style used for drawing the band itself.
     */
    style(column: string, event: Event<Index>, level: number): LevelStyle {
        let style: LevelStyle;

        if (!this.providedStyle) {
            this.providedStyle = this.providedStyleArray(this.props.column);
        }

        if (
            !_.isNull(this.providedStyle) &&
            (!_.isArray(this.providedStyle) || this.providedStyle.length !== 3)
        ) {
            console.warn("Provided style to BandChart should be an array of 3 objects");
            return defaultStyle[level];
        }

        // Is the event highlighted or selected?
        const isHighlighted = this.props.highlighted && Event.is(this.props.highlighted, event);
        const isSelected = this.props.selected && Event.is(this.props.selected, event);

        if (this.props.selected) {
            if (isSelected) {
                if (!this.selectedStyle || !this.selectedStyle[level]) {
                    if (!this.selectedStyle) {
                        this.selectedStyle = [];
                    }
                    this.selectedStyle[level] = _.merge(
                        defaultStyle[level].selected,
                        this.providedStyle[level].selected ? this.providedStyle[level].selected : {}
                    );
                }
                style = this.selectedStyle[level];
            } else if (isHighlighted) {
                if (!this.highlightedStyle || !this.highlightedStyle[level]) {
                    if (!this.highlightedStyle) {
                        this.highlightedStyle = [];
                    }
                    this.highlightedStyle[level] = _.merge(
                        defaultStyle[level].highlighted,
                        this.providedStyle[level].highlighted
                            ? this.providedStyle[level].highlighted
                            : {}
                    );
                }
                style = this.highlightedStyle[level];
            } else {
                if (!this.mutedStyle) {
                    this.mutedStyle = [];
                }
                if (!this.mutedStyle[level]) {
                    this.mutedStyle[level] = _.merge(
                        defaultStyle[level].muted,
                        this.providedStyle[level].muted ? this.providedStyle[level].muted : {}
                    );
                }
                style = this.mutedStyle[level];
            }
        } else if (isHighlighted) {
            if (!this.highlightedStyle || !this.highlightedStyle[level]) {
                if (!this.highlightedStyle) {
                    this.highlightedStyle = [];
                }
                this.highlightedStyle[level] = _.merge(
                    defaultStyle[level].highlighted,
                    this.providedStyle[level].highlighted
                        ? this.providedStyle[level].highlighted
                        : {}
                );
            }
            style = this.highlightedStyle[level];
        } else {
            if (!this.normalStyle) {
                this.normalStyle = [];
            }
            if (!this.normalStyle[level]) {
                this.normalStyle[level] = _.merge(
                    defaultStyle[level].normal,
                    this.providedStyle[level].normal ? this.providedStyle[level].normal : {}
                );
            }
            style = this.normalStyle[level];
        }
        return style;
    }

    renderAreas() {
        const { column } = this.props;

        const areas: JSX.Element[] = [];

        const styles = [];
        const event = this.series.eventList().first();
        styles[0] = this.style(column, event, 0); // eslint-disable-line
        styles[1] = this.style(column, event, 1); // eslint-disable-line
        styles[2] = this.style(column, event, 2); // eslint-disable-line

        // Use D3 to build an area generation function
        const areaGenerator = area<AreaData>()
            .curve(curves[this.props.interpolation])
            .x(d => d.x0)
            .y0(d => d.y0)
            .y1(d => d.y1);

        const columns = this.series.columns();

        // How many areas are we drawing
        let hasInner = true;
        let hasOuter = true;
        let hasCenter = true;
        if (_.has(columns, "innerMin") || _.has(columns, "innerMax")) {
            hasInner = false;
        }
        if (_.has(columns, "outerMin") || _.has(columns, "outerMax")) {
            hasOuter = false;
        }

        // Build the outer area if we have one
        if (hasOuter) {
            let level = 0;
            if (!hasInner) {
                level += 1;
            }

            const outerData: AreaData[] = [];
            for (let j = 0; j < this.series.size(); j += 1) {
                const e = this.series.at(j);
                const timestamp = new Date(
                    e.begin().getTime() + (e.end().getTime() - e.begin().getTime()) / 2
                );
                outerData.push({
                    x0: this.props.timeScale(timestamp),
                    y0: this.props.yScale(e.get("outerMin")),
                    y1: this.props.yScale(e.get("outerMax"))
                });
            }

            const outerAreaPath = areaGenerator(outerData);

            areas.push(
                <g key={`area-outer`}>
                    <path
                        d={outerAreaPath}
                        style={styles[level]}
                        onClick={e => this.handleClick(e, column)}
                        onMouseLeave={() => this.handleHoverLeave()}
                        onMouseMove={e => this.handleHover(e, column)}
                    />
                </g>
            );
        }

        if (hasInner) {
            let level = 0;
            if (!hasInner) {
                level += 1;
            }

            const innerData = [];
            for (let j = 0; j < this.series.size(); j += 1) {
                const e = this.series.at(j);
                const timestamp = new Date(
                    e.begin().getTime() + (e.end().getTime() - e.begin().getTime()) / 2
                );
                innerData.push({
                    x0: this.props.timeScale(timestamp),
                    y0: this.props.yScale(e.get("innerMin")),
                    y1: this.props.yScale(e.get("innerMax"))
                });
            }

            const innerAreaPath = areaGenerator(innerData);

            areas.push(
                <g key={`area-inner`}>
                    <path
                        d={innerAreaPath}
                        style={styles[level]}
                        onClick={e => this.handleClick(e, column)}
                        onMouseLeave={() => this.handleHoverLeave()}
                        onMouseMove={e => this.handleHover(e, column)}
                    />
                </g>
            );
        }

        return <g>{areas}</g>;
    }

    render() {
        return <g>{this.renderAreas()}</g>;
    }
}